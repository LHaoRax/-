# Leetcode中的题目启发

1. 图的遍历中删除一个节点：如果只是为了遍历，并不需要在邻接矩阵中修改其表示，只需要在visited数组中将其提前置1，则在遍历中都不会访问到它，那么其边就失去了相应的意义，等同于在图中删除了这个节点。（来自题目928）

2. 拉格朗日四平方和定理

    1. 定理内容：
        每个正整数均可表示成不超过四个整数的平方之和）

    2. 重要的推论：

        数 n 如果只能表示成四个整数的平方和，不能表示成更少的数的平方之和，必定满足$ 4^a(8b+7) $

    3. 如何利用推论求一个正整数最少需要多少个数的平方和表示：

        先判断这个数是否满足 $ 4^a(8b+7) $，如果满足，那么这个数就至少需要 4 个数的平方和表示。
    
        如果不满足，再在上面除以 4 之后的结果上暴力尝试只需要 1 个数就能表示和只需要 2 个数就能表示的情况。如果还不满足，那么就只需要 3 个数就能表示。
    
3. 将表示数的方式表示图，从而利用类似单源无权图的思想来解决最少个数的问题。（2和3来自题目279）

4. 小数点后的无限循环小数和分数之间的转化（来自题目972）

    ​    0.(12)，它代表（定义$r=\frac{1}{100}$）:
    $$
    S = \frac{12}{100}+\frac{12}{10000}+\frac{12}{10^6}+\frac{12}{10^8}+...\\
    S = 12*(r+r^2+r^3+...)\\
    S=12*\frac{r}{1-r}
    $$
    
5. 二分查找由于两个flag逐渐向目标点逼近，因此就算查找不到，其最后停止的位置也是在目标点旁边，因此也可以通过控制来找目标点相邻的元素。（来自题目463）

6. LRU缓存机制在python中可以使用OrderedDict实现。其中使用到的主要方法为：move_to_end， popitem(last=False)先进先出。（来自题目146）

7. 如果在回溯的时候将一些随着调用栈更新的的东西当做参数传递而不是当做全局变量，那么这个参数的状态会随着调用栈的改变而改变，这样就不需要手动对全局变量做出pop等操作， 省去了人为模拟调用栈所需要对全局变量进行的操作。（来自题目22）

8. 顺时针旋转一个矩阵等于转置加反转(来自题目48),反转链表直接用.reverse()来改变就可以,相当于.sort()

9. 进制转换问题,如果不是0 index的进制转换,需要将超出的0index的数字改换到0之后的位置,使得映射重新为0index,且对于这些数字会影响到前面的位数

10. 多数相加问题的通用思路为排序+双指针,如果为两数相加则双指针就够了,多几个数就需要固化几个数,例如3数相加则需要固定1个数+双指针,同时增加一定的剪枝策略(指针移动跳过某些没必要或不可能出现结果的情况).剪枝策略制定的时候应该自顶向下,先尽可能减去大分支,再减小分支.(来自题目1, 15, 16, 18)

11. 跟顺序无关的字符串匹配，只在乎个数的话可以用hashmap。（来自美团二面及题目30）

12. 下一个全排列的思路基于两个前提：1.升序序列是最小的；2.降序序列是最大的。

     1. 那么首先要找的是最后一个升序点a，因为a后面都是降序的，不可能单纯在a后面的序列中产生更大的序列，因此必须改变a的值；
     2. 这个值是最后一个比a大的元素，因为这样跟a交换位置后能有两个保证：1.a位置的值变大；2.后面依然是降序的
     3. 在a的值变化后，需要将后面变成最小的，那么什么序列最小，就是升序序列，因此需要将a后面的值reverse